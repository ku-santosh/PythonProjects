Project Folder Structure
perspective_api/
├── api/
│   └── v1/
│       └── endpoints/
│           └── perspective.py
├── database/
│   └── database.py
├── models/
│   └── perspective.py
├── schemas/
│   └── perspective.py
├── services/
│   └── perspective.py
└── main.py

main.py
import uvicorn
from fastapi import FastAPI
from .api.v1.endpoints import perspective

# Initialize the FastAPI application
app = FastAPI(title="Perspective API", version="1.0.0")

# Include the API router
app.include_router(perspective.router, prefix="/api/v1", tags=["Perspectives"])

database/database.py
import os
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from sqlalchemy.ext.declarative import declarative_base

# Define the database connection URL.
# Replace the placeholders with your actual PostgreSQL credentials.
# The database name 'skg023' and schema 'recsui' are used as specified.
DATABASE_URL = "postgresql+asyncpg://user:password@host:5432/skg023"

# Create the asynchronous database engine
engine = create_async_engine(DATABASE_URL, echo=True)

# Create a sessionmaker for generating new AsyncSession objects
AsyncSessionLocal = async_sessionmaker(
    autocommit=False, autoflush=False, bind=engine, class_=AsyncSession
)

# A base class for declarative models
Base = declarative_base()

# Dependency function to get a database session
async def get_db() -> AsyncSession:
    """Provides an asynchronous database session for endpoints."""
    async with AsyncSessionLocal() as session:
        try:
            yield session
        finally:
            await session.close()

models/perspective.py
from sqlalchemy import Column, Integer, String, JSON, DateTime, text
from sqlalchemy.sql import func
from ..database.database import Base

class Perspective(Base):
    """
    SQLAlchemy ORM model for the 'perspectives' table in the 'recsui' schema.
    This model maps to the data structure provided in the user's JSON.
    """
    __tablename__ = "perspectives"
    __table_args__ = {"schema": "recsui"}

    # id is the primary key and is auto-incremented
    id = Column(Integer, primary_key=True, index=True)

    # These fields are required and are validated to not be empty strings.
    username = Column(String, nullable=False)
    layout_name = Column(String, nullable=False)
    updated_by = Column(String, nullable=False)

    # These fields store JSON data. JSONB is used for efficient storage and querying.
    column_state = Column(JSON, nullable=False, default=text("'[]'::jsonb"))
    sort_model = Column(JSON, nullable=False, default=text("'[]'::jsonb"))
    filter_model = Column(JSON, nullable=False, default=text("'{}'::jsonb"))

    # updated_time is automatically populated with the current timestamp
    updated_time = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())

schemas/perspective.py
from datetime import datetime
from typing import Optional, List, Dict, Any
from pydantic import BaseModel, Field

# Schema for the column_state data structure
class ColumnState(BaseModel):
    name: str
    view: str
    defaultColumns: List[str]
    default: bool

# Schema for the sort_model data structure
class SortModel(BaseModel):
    name: str
    view: str
    filters: Dict[str, Any]
    default: bool

# Base schema for creating or updating a perspective.
# All fields are validated to be non-empty strings as requested.
class PerspectiveBase(BaseModel):
    username: str = Field(..., min_length=1, description="Username cannot be empty")
    layout_name: str = Field(..., min_length=1, description="Layout name cannot be empty")
    updated_by: str = Field(..., min_length=1, description="Updater's email cannot be empty")
    column_state: Optional[List[ColumnState]] = []
    sort_model: Optional[List[SortModel]] = []
    filter_model: Optional[Dict[str, Any]] = {}

# Schema for creating a new perspective (inherits from PerspectiveBase)
class PerspectiveCreate(PerspectiveBase):
    pass

# Schema for updating an existing perspective.
# All fields are optional for partial updates.
class PerspectiveUpdate(PerspectiveBase):
    username: Optional[str] = Field(None, min_length=1, description="Username cannot be empty")
    layout_name: Optional[str] = Field(None, min_length=1, description="Layout name cannot be empty")
    updated_by: Optional[str] = Field(None, min_length=1, description="Updater's email cannot be empty")
    column_state: Optional[List[ColumnState]] = None
    sort_model: Optional[List[SortModel]] = None
    filter_model: Optional[Dict[str, Any]] = None

# Full schema for a perspective, including auto-generated fields.
class Perspective(PerspectiveBase):
    id: int
    updated_time: datetime

    class Config:
        from_attributes = True

services/perspective.py
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy import update
from typing import List, Optional
from ..models.perspective import Perspective as PerspectiveModel
from ..schemas.perspective import PerspectiveCreate, PerspectiveUpdate

class PerspectiveService:
    """Service class for performing CRUD operations on Perspective data."""

    def __init__(self, db: AsyncSession):
        self.db = db

    async def get_all_perspectives(self) -> List[PerspectiveModel]:
        """
        Retrieves all perspective records from the database.
        
        Equivalent SQL query:
        SELECT id, username, layout_name, column_state, sort_model, filter_model, updated_by, updated_time
        FROM skg023.recsui.perspectives;
        """
        result = await self.db.execute(select(PerspectiveModel))
        perspectives = result.scalars().all()
        return perspectives

    async def get_perspective_by_id(self, perspective_id: int) -> Optional[PerspectiveModel]:
        """Retrieves a single perspective record by its ID."""
        result = await self.db.execute(select(PerspectiveModel).filter(PerspectiveModel.id == perspective_id))
        return result.scalars().first()

    async def create_perspective(self, perspective_in: PerspectiveCreate) -> PerspectiveModel:
        """Creates a new perspective record in the database."""
        # Create a new model instance from the input schema data
        new_perspective = PerspectiveModel(**perspective_in.model_dump())
        self.db.add(new_perspective)
        await self.db.commit()
        await self.db.refresh(new_perspective)
        return new_perspective

    async def update_perspective(self, perspective_id: int, perspective_in: PerspectiveUpdate) -> Optional[PerspectiveModel]:
        """Updates an existing perspective record."""
        # Find the existing perspective by ID
        existing_perspective = await self.db.get(PerspectiveModel, perspective_id)

        if not existing_perspective:
            return None

        # Update the model attributes with the new data from the schema
        update_data = perspective_in.model_dump(exclude_unset=True)
        for key, value in update_data.items():
            setattr(existing_perspective, key, value)

        await self.db.commit()
        await self.db.refresh(existing_perspective)
        return existing_perspective

    async def delete_perspective(self, perspective_id: int) -> bool:
        """Deletes a perspective record by its ID."""
        perspective_to_delete = await self.db.get(PerspectiveModel, perspective_id)
        if not perspective_to_delete:
            return False

        await self.db.delete(perspective_to_delete)
        await self.db.commit()
        return True

api/v1/endpoints/perspective.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List
from ...database.database import get_db
from ...schemas.perspective import Perspective, PerspectiveCreate, PerspectiveUpdate
from ...services.perspective import PerspectiveService

# Create an APIRouter for this module
router = APIRouter()

@router.get("/perspectives/", response_model=List[Perspective])
async def get_all(db: AsyncSession = Depends(get_db)):
    """Retrieves all perspectives from the database."""
    service = PerspectiveService(db)
    perspectives = await service.get_all_perspectives()
    return perspectives

@router.get("/perspectives/{perspective_id}", response_model=Perspective)
async def get_by_id(perspective_id: int, db: AsyncSession = Depends(get_db)):
    """Retrieves a single perspective by its ID."""
    service = PerspectiveService(db)
    perspective = await service.get_perspective_by_id(perspective_id)
    if not perspective:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Perspective not found")
    return perspective

@router.post("/perspectives/", response_model=Perspective, status_code=status.HTTP_201_CREATED)
async def create(perspective_in: PerspectiveCreate, db: AsyncSession = Depends(get_db)):
    """Creates a new perspective in the database."""
    service = PerspectiveService(db)
    new_perspective = await service.create_perspective(perspective_in)
    return new_perspective

@router.put("/perspectives/{perspective_id}", response_model=Perspective)
async def update(perspective_id: int, perspective_in: PerspectiveUpdate, db: AsyncSession = Depends(get_db)):
    """Updates an existing perspective by its ID."""
    service = PerspectiveService(db)
    updated_perspective = await service.update_perspective(perspective_id, perspective_in)
    if not updated_perspective:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Perspective not found")
    return updated_perspective

@router.delete("/perspectives/{perspective_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete(perspective_id: int, db: AsyncSession = Depends(get_db)):
    """Deletes a perspective by its ID."""
    service = PerspectiveService(db)
    if not await service.delete_perspective(perspective_id):
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Perspective not found")
    return
