Project Folder Structure
perspective_api/
├── api/
│   └── v1/
│       └── endpoints/
│           └── perspective.py
├── database/
│   └── database.py
├── models/
│   └── perspective.py
├── schemas/
│   └── perspective.py
├── services/
│   └── perspective.py
└── main.py

main.py

import os
from flask import Flask, g
from .api.v1.endpoints.perspective import perspective_bp
from .database.database import close_db_connection

# Initialize the Flask application
app = Flask(__name__)

# Register the blueprint for the API routes
app.register_blueprint(perspective_bp, url_prefix='/api/v1')

# Add a teardown function to close the database connection and cursor
@app.teardown_appcontext
def teardown_db(exception=None):
    conn = g.pop('db_conn', None)
    curr = g.pop('db_curr', None)
    close_db_connection(conn, curr)

if __name__ == '__main__':
    app.run(debug=True)

database/database.py

import os
import psycopg2
from psycopg2.extras import DictCursor, register_uuid
from psycopg2.extensions import connection, cursor
from flask import g
from typing import Tuple

# Register UUID support for psycopg2
register_uuid()

# Database connection details (replace with your actual details or environment variables).
DB_NAME = "skg023"
DB_USER = "your_db_user"
DB_PASSWORD = "your_db_password"
DB_HOST = "localhost"
DB_PORT = "5432"
DB_SCHEMA = "recsui"

def get_db_connection() -> Tuple[connection, cursor]:
    """
    Establishes a connection to the PostgreSQL database and returns
    both the connection and a cursor object.

    Raises:
        psycopg2.Error: If the connection fails.
    """
    try:
        conn = psycopg2.connect(
            dbname=DB_NAME,
            user=DB_USER,
            password=DB_PASSWORD,
            host=DB_HOST,
            port=DB_PORT,
        )
        # Use DictCursor to return query results as dictionaries
        curr = conn.cursor(cursor_factory=DictCursor)
        curr.execute(f"SET search_path TO {DB_SCHEMA};")
        print("Successfully connected to the database.")
        return conn, curr
    except psycopg2.Error as e:
        print(f"Error connecting to the database: {e}")
        raise

def close_db_connection(conn: connection, curr: cursor):
    """Closes the database cursor and connection."""
    if curr:
        curr.close()
    if conn:
        conn.close()
    print("Database connection closed.")

def get_db():
    """
    Provides a database connection and cursor that is local to the current request.
    If they don't exist for the request, it creates new ones.
    """
    if 'db_conn' not in g or 'db_curr' not in g:
        try:
            conn, curr = get_db_connection()
            g.db_conn = conn
            g.db_curr = curr
        except psycopg2.Error as e:
            raise ConnectionError(f"Failed to get database connection: {e}") from e
    
    return g.db_conn, g.db_curr

models/perspective.py

from typing import Optional, List, Dict, Any
from datetime import datetime

class ColumnState:
    """Represents the structure of a single item in the column_state array."""
    def __init__(self, name: str, view: str, defaultColumns: List[str], default: bool):
        self.name = name
        self.view = view
        self.defaultColumns = defaultColumns
        self.default = default

class FilterDetail:
    """Represents the structure of a filter detail."""
    def __init__(self, type: str, filter: str):
        self.type = type
        self.filter = filter

class ViewSetting:
    """Represents the structure of a single item in the sort_model or filter_model arrays."""
    def __init__(self, name: str, view: str, filters: Dict[str, FilterDetail], default: bool):
        self.name = name
        self.view = view
        self.filters = filters
        self.default = default

class Perspective:
    """
    Data Transfer Object (DTO) for the 'perspectives' table.
    This class is not tied to an ORM and is used to represent a database row.
    """
    def __init__(self, id: int, username: str, layout_name: str, updated_by: str,
                 column_state: List[ColumnState], sort_model: List[ViewSetting],
                 filter_model: List[ViewSetting], updated_time: datetime):
        self.id = id
        self.username = username
        self.layout_name = layout_name
        self.updated_by = updated_by
        self.column_state = column_state
        self.sort_model = sort_model
        self.filter_model = filter_model
        self.updated_time = updated_time

    @staticmethod
    def from_dict(data: dict):
        """Converts a dictionary (from a psycopg2 query) to a Perspective object."""
        if not data:
            return None
        
        # Recursively create objects for nested data
        column_state = [ColumnState(**cs) for cs in data.get('column_state', [])]
        
        sort_model = []
        for sm in data.get('sort_model', []):
            filters = {k: FilterDetail(**v) for k, v in sm.get('filters', {}).items()}
            sort_model.append(ViewSetting(name=sm['name'], view=sm['view'], filters=filters, default=sm['default']))

        filter_model = []
        for fm in data.get('filter_model', []):
            filters = {k: FilterDetail(**v) for k, v in fm.get('filters', {}).items()}
            filter_model.append(ViewSetting(name=fm['name'], view=fm['view'], filters=filters, default=fm['default']))
        
        return Perspective(
            id=data['id'],
            username=data['username'],
            layout_name=data['layout_name'],
            updated_by=data['updated_by'],
            column_state=column_state,
            sort_model=sort_model,
            filter_model=filter_model,
            updated_time=data['updated_time']
        )

schemas/perspective.py

from datetime import datetime
from typing import Optional, List, Dict, Any
from pydantic import BaseModel, Field, model_serializer

# Schema for the nested filter details within sort and filter models
class FilterDetail(BaseModel):
    type: str
    filter: str

# Schema for the column_state data structure
class ColumnState(BaseModel):
    name: str
    view: str
    defaultColumns: List[str]
    default: bool

# Schema for the sort_model and filter_model data structures
class ViewSetting(BaseModel):
    name: str
    view: str
    filters: Dict[str, FilterDetail]
    default: bool

# Base schema for creating or updating a perspective.
# All fields are validated to be non-empty strings as requested.
class PerspectiveBase(BaseModel):
    username: str = Field(..., min_length=1, description="Username cannot be empty")
    layout_name: str = Field(..., min_length=1, description="Layout name cannot be empty")
    updated_by: str = Field(..., min_length=1, description="Updater's email cannot be empty")
    column_state: Optional[List[ColumnState]] = []
    sort_model: Optional[List[ViewSetting]] = []
    filter_model: Optional[List[ViewSetting]] = []

# Schema for creating a new perspective (inherits from PerspectiveBase)
class PerspectiveCreate(PerspectiveBase):
    pass

# Schema for updating an existing perspective.
# All fields are optional for partial updates.
class PerspectiveUpdate(PerspectiveBase):
    username: Optional[str] = Field(None, min_length=1, description="Username cannot be empty")
    layout_name: Optional[str] = Field(None, min_length=1, description="Layout name cannot be empty")
    updated_by: Optional[str] = Field(None, min_length=1, description="Updater's email cannot be empty")
    column_state: Optional[List[ColumnState]] = None
    sort_model: Optional[List[ViewSetting]] = None
    filter_model: Optional[List[ViewSetting]] = None

# Full schema for a perspective, including auto-generated fields.
class Perspective(PerspectiveBase):
    id: int
    updated_time: str

    class Config:
        from_attributes = True

services/perspective.py

import psycopg2
from psycopg2.extras import DictCursor
from typing import List, Optional
import json
from ..models.perspective import Perspective as PerspectiveModel
from ..schemas.perspective import PerspectiveCreate, PerspectiveUpdate
from psycopg2.extensions import connection, cursor

class PerspectiveService:
    """Service class for performing CRUD operations on Perspective data using psycopg2."""

    def __init__(self, db_conn: connection, db_curr: cursor):
        self.db_conn = db_conn
        self.db_curr = db_curr

    def get_all_perspectives(self) -> List[PerspectiveModel]:
        """Retrieves all perspective records from the database."""
        self.db_curr.execute("SELECT * FROM recsui.perspectives;")
        perspectives = self.db_curr.fetchall()
        return [PerspectiveModel.from_dict(p) for p in perspectives]

    def get_perspective_by_id(self, perspective_id: int) -> Optional[PerspectiveModel]:
        """Retrieves a single perspective record by its ID."""
        self.db_curr.execute("SELECT * FROM recsui.perspectives WHERE id = %s;", (perspective_id,))
        perspective = self.db_curr.fetchone()
        return PerspectiveModel.from_dict(perspective)

    def create_perspective(self, perspective_in: PerspectiveCreate) -> PerspectiveModel:
        """Creates a new perspective record in the database."""
        # Convert Pydantic models to JSON strings for database insertion
        column_state_json = json.dumps([cs.model_dump() for cs in perspective_in.column_state])
        sort_model_json = json.dumps([sm.model_dump() for sm in perspective_in.sort_model])
        filter_model_json = json.dumps([fm.model_dump() for fm in perspective_in.filter_model])
        
        try:
            self.db_curr.execute(
                """
                INSERT INTO recsui.perspectives (username, layout_name, updated_by, column_state, sort_model, filter_model)
                VALUES (%s, %s, %s, %s, %s, %s)
                RETURNING *;
                """,
                (
                    perspective_in.username,
                    perspective_in.layout_name,
                    perspective_in.updated_by,
                    column_state_json,
                    sort_model_json,
                    filter_model_json
                )
            )
            new_perspective = self.db_curr.fetchone()
            self.db_conn.commit()
            return PerspectiveModel.from_dict(new_perspective)
        except Exception as e:
            self.db_conn.rollback()
            raise e

    def update_perspective(self, perspective_id: int, perspective_in: PerspectiveUpdate) -> Optional[PerspectiveModel]:
        """Updates an existing perspective record."""
        # Check if the perspective exists
        perspective_to_update = self.get_perspective_by_id(perspective_id)
        if not perspective_to_update:
            return None
        
        # Build the update query dynamically
        update_clauses = []
        update_data = []
        
        # Convert Pydantic models to JSON strings for database update
        perspective_dict = perspective_in.model_dump(exclude_unset=True)
        
        if 'username' in perspective_dict:
            update_clauses.append("username = %s")
            update_data.append(perspective_dict['username'])
        if 'layout_name' in perspective_dict:
            update_clauses.append("layout_name = %s")
            update_data.append(perspective_dict['layout_name'])
        if 'updated_by' in perspective_dict:
            update_clauses.append("updated_by = %s")
            update_data.append(perspective_dict['updated_by'])
        if 'column_state' in perspective_dict:
            update_clauses.append("column_state = %s")
            update_data.append(json.dumps([cs.model_dump() for cs in perspective_in.column_state]))
        if 'sort_model' in perspective_dict:
            update_clauses.append("sort_model = %s")
            update_data.append(json.dumps([sm.model_dump() for sm in perspective_in.sort_model]))
        if 'filter_model' in perspective_dict:
            update_clauses.append("filter_model = %s")
            update_data.append(json.dumps([fm.model_dump() for fm in perspective_in.filter_model]))

        if not update_clauses:
            return perspective_to_update # No changes to apply

        query = f"UPDATE recsui.perspectives SET {', '.join(update_clauses)} WHERE id = %s RETURNING *;"
        update_data.append(perspective_id)
        
        try:
            self.db_curr.execute(query, tuple(update_data))
            updated_perspective = self.db_curr.fetchone()
            self.db_conn.commit()
            return PerspectiveModel.from_dict(updated_perspective)
        except Exception as e:
            self.db_conn.rollback()
            raise e

    def delete_perspective(self, perspective_id: int) -> bool:
        """Deletes a perspective record by its ID."""
        try:
            self.db_curr.execute("DELETE FROM recsui.perspectives WHERE id = %s RETURNING id;", (perspective_id,))
            deleted_row = self.db_curr.fetchone()
            if deleted_row:
                self.db_conn.commit()
                return True
            else:
                self.db_conn.rollback()
                return False
        except Exception as e:
            self.db_conn.rollback()
            raise e

api/v1/endpoints/perspective.py

from flask import Blueprint, jsonify, request
import psycopg2
from pydantic import ValidationError
from typing import List
from ..database.database import get_db
from ..schemas.perspective import Perspective, PerspectiveCreate, PerspectiveUpdate
from ..services.perspective import PerspectiveService

# Create a Blueprint for this module
perspective_bp = Blueprint('perspective_bp', __name__)

@perspective_bp.route("/perspectives/", methods=["GET"])
def get_all():
    """Retrieves all perspectives from the database."""
    conn, curr = get_db()
    try:
        service = PerspectiveService(conn, curr)
        perspectives = service.get_all_perspectives()
        # The serializer in the Perspective schema now expects a dictionary-like object,
        # which our DTO provides.
        return jsonify([Perspective(**p.__dict__).model_dump() for p in perspectives])
    except Exception as e:
        return jsonify({"detail": str(e)}), 500

@perspective_bp.route("/perspectives/<int:perspective_id>", methods=["GET"])
def get_by_id(perspective_id: int):
    """Retrieves a single perspective by its ID."""
    conn, curr = get_db()
    try:
        service = PerspectiveService(conn, curr)
        perspective = service.get_perspective_by_id(perspective_id)
        if not perspective:
            return jsonify({"detail": "Perspective not found"}), 404
        return jsonify(Perspective(**perspective.__dict__).model_dump())
    except Exception as e:
        return jsonify({"detail": str(e)}), 500

@perspective_bp.route("/perspectives/", methods=["POST"])
def create():
    """Creates a new perspective in the database."""
    conn, curr = get_db()
    try:
        perspective_in = PerspectiveCreate(**request.json)
    except ValidationError as e:
        return jsonify({"detail": e.errors()}), 422
    
    try:
        service = PerspectiveService(conn, curr)
        new_perspective = service.create_perspective(perspective_in)
        return jsonify(Perspective(**new_perspective.__dict__).model_dump()), 201
    except Exception as e:
        return jsonify({"detail": str(e)}), 500

@perspective_bp.route("/perspectives/<int:perspective_id>", methods=["PUT"])
def update(perspective_id: int):
    """Updates an existing perspective by its ID."""
    conn, curr = get_db()
    try:
        perspective_in = PerspectiveUpdate(**request.json)
    except ValidationError as e:
        return jsonify({"detail": e.errors()}), 422
    
    try:
        service = PerspectiveService(conn, curr)
        updated_perspective = service.update_perspective(perspective_id, perspective_in)
        if not updated_perspective:
            return jsonify({"detail": "Perspective not found"}), 404
        return jsonify(Perspective(**updated_perspective.__dict__).model_dump())
    except Exception as e:
        return jsonify({"detail": str(e)}), 500

@perspective_bp.route("/perspectives/<int:perspective_id>", methods=["DELETE"])
def delete(perspective_id: int):
    """Deletes a perspective by its ID."""
    conn, curr = get_db()
    try:
        service = PerspectiveService(conn, curr)
        if not service.delete_perspective(perspective_id):
            return jsonify({"detail": "Perspective not found"}), 404
        return "", 204
    except Exception as e:
        return jsonify({"detail": str(e)}), 500
